/*
 * Loader Implementation
 *
 * 2022, Operating Systems
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>

#include "exec_parser.h"

#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
static so_exec_t *exec;
static struct sigaction default_handler;

static int fd;


static void segv_handler(int signum, siginfo_t *info, void *context)
{
	/* TODO - actual loader implementation */
	if(signum != SIGSEGV || info == NULL){
		default_handler.sa_sigaction(signum,info,context);
		return;
	}else{
		int seg_gasit=0;
		int i=0;
		so_seg_t *segment_gasit;
		for(i=0; i<exec->segments_no; i++){
			segment_gasit = (exec->segments) + i;
			if( segment_gasit->vaddr <= (int)info->si_addr && (int)info->si_addr <= segment_gasit->vaddr + segment_gasit->mem_size){
				seg_gasit=1;
				break;
			}
		}
		if(seg_gasit==0 || info->si_code != SEGV_MAPERR){
			default_handler.sa_sigaction(signum,info,context);
			return;
		}

		int dim_pag = getpagesize();
		int nr_pagini = (segment_gasit->vaddr + segment_gasit->mem_size) / dim_pag;
		int pag_gasita=-1;
		uintptr_t pagina;
		int pag;

		for(pag=0; pag<nr_pagini; pag++){
			pagina = segment_gasit->vaddr + pag*dim_pag;
			if(pagina <= (int)info->si_addr && (int)info->si_addr < pagina + dim_pag){
				pag_gasita=pag;
				break;
			}
		}
		if(pag_gasita == -1){
			default_handler.sa_sigaction(signum,info,context);
			return;
		}
		//daca ajungem aici am gasit pagina
		void *return_mmap = mmap((void *)pagina, dim_pag, PERM_R | PERM_W, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
		if(return_mmap == MAP_FAILED){
			default_handler.sa_sigaction(signum,info,context);
			return;
		}
		if(pagina <= segment_gasit->vaddr + segment_gasit->file_size ){
			if(lseek(fd, segment_gasit->offset + pag*dim_pag, SEEK_SET) < 0){
				default_handler.sa_sigaction(signum,info,context);
				return;
			}
			int cat_citim;
			if(segment_gasit->file_size - dim_pag*pag < dim_pag)
				cat_citim=segment_gasit->file_size - dim_pag*pag;
			else
				cat_citim = dim_pag;
			lseek(fd, segment_gasit->offset + pag*dim_pag, SEEK_SET);
			read(fd, (void *)return_mmap, cat_citim);		
		}
		mprotect(return_mmap, dim_pag, segment_gasit->perm);
		return;
	}
	signal(SIGSEGV, NULL);
}

int so_init_loader(void)
{
	int rc;
	struct sigaction sa;

	memset(&sa, 0, sizeof(sa));
	sa.sa_sigaction = segv_handler;
	sa.sa_flags = SA_SIGINFO;
	rc = sigaction(SIGSEGV, &sa, &default_handler);
	if (rc < 0) {
		perror("sigaction");
		return -1;
	}
	return 0;
}

int so_execute(char *path, char *argv[])
{
	fd=open(path, O_RDONLY);

	exec = so_parse_exec(path);
	if (!exec)
		return -1;

	so_start_exec(exec, argv);

	close(fd);

	return -1;
}
